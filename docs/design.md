# Git-Eval: コード提出によるスキルグレード認定システム

## ビジョン

Git を知らない完全初心者が、このシステムの課題をクリアしていくだけで、
技術選定にうるさいレベルのエンジニアにまで成長できる道筋を提供する。

技術者が集まる Discord サーバー向け。
GitHub にコードを push すると CI/CD + LLM が自動で評価し、
スコアに応じて Discord ロールが昇格していく。

---

## 全体フロー

```
1. Discord Bot で /register <github-username> してアカウント紐付け
2. 自分のリポジトリに .github/workflows/git-eval.yml を追加
3. コードを push
4. GitHub Actions が起動
   a. CI/CD で機械的評価（現ランクのルーブリックに基づく）
   b. Claude API で定性的評価（現ランクのルーブリックに基づく）
5. スコア算出 → Discord Bot 経由でフィードバック通知
6. 累積スコアに応じて Discord ロールを自動更新
```

---

## 提出方法

ユーザーの任意のリポジトリに GitHub Actions ワークフロー（`git-eval.yml`）を
1 枚追加してもらうだけ。push するたびに自動で評価が走る。

- 初心者: G ランクのお題リポジトリを作って YAML を入れるところから誘導
- 上級者: 既存の自分のプロジェクトにそのまま YAML を追加
- リポジトリの作り直しは不要、1 つのリポジトリで継続的に提出できる
- Git リポジトリの利用促進にもなる

---

## ランクガイド（ユーザー向け事前開示）

評価基準は **すべて事前にユーザーへ開示する**。
知らないルールで減点されるのはただの理不尽なので、
「何を見るか」「何をやったら即アウトか」は提出前に必ず見える状態にする。

- Discord Bot の `/guide` コマンドで現在ランクの評価基準・即アウト条件を表示
- 各ランクのガイドには「このランクで求められること」「やってはいけないこと」を明記
- ランクが上がったタイミングで次のランクのガイドを自動通知

例（F ランクのガイド）:
```
【F ランク: Foundation】
このランクでは「開発を始められる状態」を自分で作れるかを見ます。

■ 評価ポイント
- プロジェクトを初期化できているか
- .gitignore が適切に設定されているか
- .gitattributes で改行コードを管理できているか

■ 即アウト条件（0 点）
- .env ファイルが push されている
- CRLF 改行のファイルが含まれている
```

---

## グレード体系

各グレードは Discord ロールに対応し、成長段階に沿った評価を行う。
昇格時に旧ロールは剥奪し、最新ランクのみ保持する。

### G（Generalist）― ターミナルと Git の基礎 **【AI 利用禁止】**

覚えれば効率が爆上がりするものを、自分の手で叩いて身につける。
このランクだけは AI 禁止。ここは「知ってるかどうか」の世界なので、
AI に頼らず自力で覚えることに意味がある。

| 評価観点 | 内容 |
|---------|------|
| ターミナル基礎 | `cd`, `ls`, `mkdir`, `cp`, `mv`, `rm`, `code .` 等の基本コマンド |
| パスの理解 | 絶対パス・相対パスの違いがわかる |
| Git 基礎 | `init`, `add`, `commit`, `push`, `pull`, `clone` |
| ブランチ操作 | `branch` / `switch -c`|
| GitHub 操作 | リポジトリ作成、PR を出す、マージする |

- CI/CD のみで機械的にチェック（LLM 不要）
- お題形式で「この操作をやってみよう」的な課題を出す
- 例: PS1 をカスタマイズしてみよう、など

### F（Foundation）― 開発環境とプロジェクトの型を知る

ターミナルと Git が使える前提で、「開発を始められる状態」を自分で作れるかを見る。

| 評価観点 | 内容 |
|---------|------|
| 環境構築 | 言語・ランタイムのインストール、パッケージマネージャの利用 |
| プロジェクト初期化 | `npm init`, `cargo init` 等でゼロからプロジェクトを作れる |
| ディレクトリ構成 | 一般的なプロジェクト構造を理解している |
| .gitignore | 不要ファイルを管理対象から除外できる |
| .env | 環境変数ファイルの扱いを理解している（**push したら即アウト**） |
| .gitattributes | 改行コードの管理ができる（**CRLF で push したら即アウト**） |
| 設定ファイル | エディタ設定、リンター設定などの基本的な設定ができる |

- CI/CD 中心（プロジェクト構造・設定ファイルの有無をチェック）
- `.env` の混入、CRLF 改行は CI で機械的に検出 → 即 0 点
- LLM は軽く補助（ディレクトリ構成の妥当性など）

### E（Emerging）― 基本的なコードが書ける

手を動かしてコードを書き始める段階。
まずは小さいプログラムが動くことをゴールにする。

| 評価観点 | 内容 |
|---------|------|
| 文法 | 基本的な構文エラーがない |
| 実行 | プログラムが動作する |
| 入出力 | 標準入出力やファイル操作ができる |
| 基本構造 | 変数、関数、条件分岐、ループを使えている |

- CI/CD 中心（ビルド通過・実行成功の確認）
- LLM はコードの基本的な書き方をチェック

### D（Developer）― チーム開発を意識した Git 運用

個人で書けるだけでなく、チームで開発する作法が身についているかを見る。

| 評価観点 | 内容 |
|---------|------|
| コミット | 意味のあるコミットメッセージを書ける |
| ブランチ戦略 | 機能ごとにブランチを切って作業できる |
| PR | わかりやすい PR の説明が書ける |
| コードの分割 | 1 コミット・1 PR の粒度が適切 |

- CI/CD でコミット履歴・ブランチ構成を機械的にチェック
- LLM はコミットメッセージ・PR 説明文の質を評価

### C（Competent）― 動くだけでなく「ちゃんと動く」ものを作れる

コードが動くのは当たり前。テストやリンターを通す習慣があるかを見る。

| 評価観点 | 内容 |
|---------|------|
| ビルド | コンパイル / ビルドが通る |
| テスト | 最低限のテストがある |
| リンター | 静的解析を通せる |
| 再現性 | 他の人が clone して動かせる（README の手順等） |

- CI/CD の比重が高い
- LLM はコードの基本的な読みやすさを軽くチェック

### B（Builder）― 読みやすく保守しやすいコードが書ける

| 評価観点 | 内容 |
|---------|------|
| 可読性 | 命名・構造がわかりやすい |
| 設計 | 適切な関心の分離 |
| エラーハンドリング | 異常系の考慮 |
| ドキュメント | README・コメントが過不足ない |

- LLM の比重が上がる
- CI/CD はカバレッジ・複雑度などの定量指標

### A（Architect）― 設計判断ができる

| 評価観点 | 内容 |
|---------|------|
| アーキテクチャ | 全体設計の妥当性 |
| イディオム | 言語らしい書き方 |
| トレードオフ | 技術選択の根拠が明確 |
| セキュリティ | 脆弱性への配慮 |
| 判断の説明 | なぜその技術を選んだかを言語化できる |

- LLM 中心の評価
- **`DECISION.md` の添付を推奨** （後述）

### S（Specialist）― 技術選定にうるさいレベル

| 評価観点 | 内容 |
|---------|------|
| 技術選定 | 目的に対して最適な手段を選べている |
| 目的と手段の一致 | オーバースペックや不足がない |
| 創意工夫 | 独自のアプローチ・最適化 |
| 総合力 | 上記すべてを高水準で満たす |

- LLM による深い評価が必須
- 目的と手段の逆転には厳しく減点
- **`DECISION.md` の添付を強く推奨**

---

## DECISION.md（設計判断ドキュメント）

B ランク以上、特に A・S では「なぜそうしたか」が評価の核になる。
LLM がコードだけ見て謎の減点をしないよう、設計判断を説明する
`DECISION.md` の添付を推奨する。

記載例:
- なぜこの技術/ライブラリを選んだか
- 何を想定してこの設計にしたか
- なぜ機能をあえて削った/シンプルにしたか
- 既知の妥協点とその理由

LLM は `DECISION.md` がある場合、コードと突き合わせて
「判断の妥当性」を評価する。ない場合はコードのみで判断する。

---

## 評価方式

### ルーブリック（採点基準表）ベース

Claude に「いい感じに判定して」ではなく、ランクごとに明文化した
採点基準表（ルーブリック）を渡して採点させる。

- 各ランクのルーブリックは **そのランクの観点だけ** を見る
  - G なら「`cd` で移動できてるか」、S なら「技術選定の根拠」
  - ランクに関係ない観点では減点しない
- CI/CD の定量データ（テスト結果、リンター出力等）も Claude に渡し、
  ルーブリックの裏付けとして使う

### スコア

- 1 回の提出で 0〜100 点
- 累積制（グレードは下がらない）
- 必要累積スコアはゆるい指数関数的に増加

### 飛び級（スキップ）

実力者が足踏みしないための仕組み。

- 通常評価に加え、上位ランクのルーブリックにも通す
- 上位ルーブリックで閾値を超えた場合、飛び級フラグが立つ
- フラグが立てば、ボーナス倍率 or 該当ランクまでの一括スコア加算

例: 現在 E ランクの人が明らかに B 級の成果物を出した場合
→ B ランクのルーブリックでも高スコア → 飛び級で一気に B へ

---

## 決定事項

| 項目 | 方針 |
|------|------|
| LLM | Claude メイン（精度向上するなら Gemini 併用もあり） |
| 評価方式 | ランクごとのルーブリックを Claude に渡して採点 |
| 評価ウェイト | 低ランクは CI/CD 寄り → 高ランクほど LLM 寄り |
| 対応言語 | 制限なし。ただし S ランクでは技術選定の妥当性を厳しく見る |
| AI 利用 | G ランクのみ禁止。F 以降は制限なし、成果物の質のみで評価 |
| 提出方法 | ユーザーのリポジトリに `git-eval.yml` を追加してもらう |
| YAML 改ざん対策 | VPS 側でハッシュ検証。改ざん検出時は -10 点 + 煽りメッセージ |
| 評価タイミング | 最後の push から N 分後にデバウンスして 1 回だけ評価 |
| フィードバック | Discord 通知。スコア内訳 + 改善点のフィードバック付き |
| ステータス確認 | Discord Bot で `/status` → 現在ランク・累積スコア・次ランクまでの距離 |
| ランクガイド | `/guide` で現在ランクの評価基準・即アウト条件を事前開示。昇格時に次ランクのガイドを自動通知 |
| コード送信 | リポジトリのコードをそのまま Claude に渡す（巨大リポジトリは想定外） |
| アカウント紐付け | Discord Bot で `/register <github-username>` |
| Bot ホスティング | VPS に常駐。省リソース設計 |
| VPS 通信 | GitHub Actions から VPS の API エンドポイントに Webhook |
| スコア保存 | VPS、または Git リポジトリ内に JSON 等で保持 |
| スコア進行 | ゆるい指数関数的。飛び級あり |
| ロール昇格演出 | Discord チャンネルに「@○○ さんが A ランクに昇格！」と通知 |

---

## アーキテクチャ

```
ユーザーのリポジトリ（git-eval.yml 入り）
  │
  ├── push イベント
  ▼
GitHub Actions（git-eval.yml）
  ├── CI/CD 評価（ビルド・テスト・静的解析）
  ├── Claude API 呼び出し（ルーブリック + CI/CD 結果を渡す）
  ├── スコア算出（通常 + 飛び級判定）
  └── 結果を VPS に送信
          │
          ▼
VPS
  ├── スコアストア（累積スコア管理）
  └── Discord Bot
        ├── スコア通知・フィードバック
        ├── ロール付与・更新
        └── 昇格通知
```

---

## 未決事項

- [ ] 各ランクの具体的なルーブリック（採点基準の詳細）
- [ ] 各ランクの具体的なお題案（階段的に: 初心者でも行ける → 経験者向け）
- [ ] グレードごとの必要累積スコアの具体的な数値
- [ ] 飛び級の閾値・倍率の具体的な設計
- [ ] マルチリポジトリ対応と改善サイクルの仕組み

